# #############################################################################
# lofar_bootes_nufft.py
# ======================
# Author : Matthieu Simeoni [matthieu.simeoni@gmail.com]
# #############################################################################

"""
Simulation LOFAR imaging with Bluebild (NUFFT).

Differences with mwa_test: 
1
- when using ms baselines here -1 is multiplied and image is consistent
in mwa_test when -1 is multiplied to the ms baselines image is inconsistent
2
- Here the pix_xyz is generated by np.tensordot(uvw_frame.transpose(), lmn_grid, axes=1)
in pypeline/pypeline/phased_array/bluebild/field_synthesizer/fourier_domain.py it is generated by:
uvw_frame = frame.uvw_basis(self._field_center)
xyz_grid = np.tensordot(uvw_frame, lmn_grid, axes=1)
when .T is added - image is rotated by 45 degrees or so
3
- 
"""

from tqdm import tqdm as ProgressBar
import astropy.units as u
import astropy.coordinates as coord
import astropy.time as atime
import imot_tools.io.s2image as s2image
import imot_tools.math.sphere.grid as grid
import matplotlib.pyplot as plt
import numpy as np

import scipy.constants as constants
import scipy.sparse as sparse
import finufft
from imot_tools.io.plot import cmap
import pypeline.phased_array.beamforming as beamforming
import pypeline.phased_array.bluebild.data_processor as bb_dp
import pypeline.phased_array.bluebild.gram as bb_gr
import pypeline.phased_array.bluebild.imager.fourier_domain as bb_fd
import pypeline.phased_array.bluebild.parameter_estimator as bb_pe
import pypeline.phased_array.data_gen.source as source
from  pypeline.util.frame import xyz_to_uvw, xyz_at_latitude
import pypeline.phased_array.instrument as instrument
import imot_tools.math.sphere.interpolate as interpolate
import imot_tools.math.sphere.transform as transform
import pypeline.phased_array.data_gen.statistics as statistics
import pypeline.phased_array.measurement_set as measurement_set
import imot_tools.io.fits as ifits
from imot_tools.math.func import SphericalDirichlet
from mpl_toolkits.mplot3d import Axes3D
import imot_tools.io.s2image as im
import time as tt
import sys
np.set_printoptions(threshold=sys.maxsize)
import scipy.linalg as linalg
import astropy.io.fits as ap_fits

np.set_printoptions(threshold=sys.maxsize)

from mpl_toolkits.axes_grid1 import make_axes_locatable
import matplotlib.colors as colors
plt.rcParams.update({'font.size': 6})

def RX(teta):
    return np.array([[ 1.0,          0.0,           0.0],
                     [ 0.0,  np.cos(teta),  np.sin(teta)],
                     [ 0.0, -np.sin(teta),  np.cos(teta)]])

def RY(teta):
    return np.array([[ np.cos(teta),  0.0, -np.sin(teta)],
                     [          0.0,  1.0,           0.0],
                     [ np.sin(teta),  0.0,  np.cos(teta)]])

def RZ(teta):
    return np.array([[  np.cos(teta),  np.sin(teta), 0.0],
                     [ -np.sin(teta),  np.cos(teta), 0.0],
                     [           0.0,           0.0, 1.0]])


### DEFINE SOURCE
### Must correspond to what was used to generate the MS file with RASCIL
source = coord.SkyCoord(ra = 248.7713797* u.deg, dec = -22.0545530* u.deg, frame = 'icrs')
#source = coord.SkyCoord(ra = 250.23032396 * u.deg, dec = -19.67371658 * u.deg, frame = 'icrs')

### DEFINE UVW FRAME
### Rotate X,Y plane so that it becomes tangent to celestial sphere at source with
### with Z'' (i.e. w) pointing to source and Y'' (i.e. v) lookind Nothwards to match convention.
uvw_frame = RX(np.pi/2 - source.dec.rad) @ RZ(np.pi/2 + source.ra.rad)
print (uvw_frame)

# From https://ska-telescope.gitlab.io/external/rascil/_modules/rascil/processing_components/simulation/configurations.html#create_configuration_from_file
#low_location = coord.EarthLocation(
#    lon=116.76444824 * u.deg, lat=-26.824722084 * u.deg, height=300.0
#)

ms_file = "/work/ska/MWA/1133149192-187-188_Sun_10s_cal.ms"
WSClean_image_path = "/scratch/izar/krishna/MWA/WSClean/individual_channels/1133149192-187-188_Sun_10s_cal1024_Pixels_4_5_channels_50_cellsize-image.fits" # only channel 4
#WSClean_image_path = "/scratch/izar/krishna/MWA/WSClean/individual_channels/1133149192-187-188_Sun_10s_cal.ms_WSClean-image.fits"
cl_WCS = ifits.wcs(WSClean_image_path)
ms = measurement_set.MwaMeasurementSet(ms_file) # stations 1 - N_station 
time_start = 0
time_end = 1
time_chunk = 1

use_raw_vis = False # Use visibilities from .ms file
do3D        = True  # 3D NUFFT 
doPlan      = False # ??

for use_raw_vis in  True, False :
    for use_ms in True, False:

        print (f"use_raw_vis:{use_raw_vis}, use_ms:{use_ms}")
        read_coords_from_ms = use_ms
        uvw_from_ms         = use_ms

        outfilename = 'test_mwa_nufft_' + ('msUVW_' if uvw_from_ms else '') + ('rawVis_' if use_raw_vis else 'BBVis')

        gram = bb_gr.GramBlock()

        cl_WCS = cl_WCS.sub(['celestial'])
        width_px, height_px= 2*cl_WCS.wcs.crpix 
        cdelt_x, cdelt_y = cl_WCS.wcs.cdelt 
        #FoV = np.deg2rad(abs(cdelt_x*width_px) )
        FoV = np.deg2rad(5)
        source = ms.field_center
            
        print("Reading {0}\n".format(ms_file))
        print("FoV is ", np.rad2deg(FoV))

        #channel_id = 100
        channel_id = 4 #64
        #frequency = 1e8
        N_pix = 500 # changed from 256
        freq_ms = ms.channels["FREQUENCY"][channel_id]
        frequency = freq_ms.to_value(u.Hz)
        wl = constants.speed_of_light / frequency
        #print(freq_ms.to_value(u.Hz), frequency)
        #assert freq_ms.to_value(u.Hz) == frequency
        obs_start, obs_end = ms.time["TIME"][[0, -1]]

        # Imaging Parameters
        #t1 = tt.time()
        N_level = 1

        ### Intensity Field ===========================================================
        # Parameter Estimation
        I_est = bb_pe.IntensityFieldParameterEstimator(N_level, sigma=1)
        for t, f, S in ms.visibilities(channel_id=[channel_id], time_id=slice(time_start, time_end, time_chunk), column="DATA"):
            wl = constants.speed_of_light / f.to_value(u.Hz)
            XYZ = ms.instrument(t)
            W = ms.beamformer(XYZ, wl)
            G = gram(XYZ, W, wl)
            S, _ = measurement_set.filter_data(S, W)
            I_est.collect(S, G)

        N_eig, c_centroid = I_est.infer_parameters()
        print(f"N_eig:{N_eig} centroids = {c_centroid}")

        # Imaging
        I_dp = bb_dp.IntensityFieldDataProcessorBlock(N_eig, c_centroid)
        UVW_baselines = []
        gram_corrected_visibilities = []

        baseline_rescaling = 2 * np.pi / wl

        timestep = 0
        for t, f, S, uvw in ms.visibilities(channel_id=[channel_id], time_id=slice(time_start, time_end, time_chunk), column="DATA", return_UVW=True):
            print (f"UVW from MS: {uvw}")
            XYZ = ms.instrument(t)
            wl = constants.speed_of_light / f.to_value(u.Hz)
            print(f"Timestep: {timestep}, frequency: {f.to_value(u.Hz)},wavelength:{wl}")

            # Imaging grid
            lim = np.sin(FoV / 2)
            
            pix_slice = np.linspace(-lim, lim, N_pix)
            Lpix, Mpix = np.meshgrid(pix_slice, pix_slice)
            Jpix = np.sqrt(1 - Lpix ** 2 - Mpix ** 2)  # No -1 if r on the sphere !
            lmn_grid = np.stack((Lpix, Mpix, Jpix), axis=0)
            pix_xyz = np.tensordot(uvw_frame.transpose(), lmn_grid, axes=1)  #EO: check this one!
            
            if uvw_from_ms:
                print("BB using MS")
                UVW_baselines_t = -uvw
            else:
                print("BB on his own")
                UVW = (uvw_frame @ XYZ.data.transpose()).transpose()
                UVW_baselines_t = (UVW[:, None, :] - UVW[None, ...])
            
            UVW_baselines.append(baseline_rescaling * UVW_baselines_t)
            print (f"UVW added to list: {baseline_rescaling * UVW_baselines_t}")

            # one 2 pi/wl factor
            
            ###ICRS_baselines.append(baseline_rescaling * ICRS_baselines_t)
            W = ms.beamformer(XYZ, wl)
            G = gram(XYZ, W, wl)
            """
            fig_gram, ax_gram = plt.subplots(2,2)
            gram_real = ax_gram[0,0].imshow(np.real(G.data))
            ax_gram[0,0].set_title("G (Real)")
            divider = make_axes_locatable(ax_gram[0, 0])
            cax = divider.append_axes("right", size="5%", pad=0.05)
            cbar = plt.colorbar(gram_real, cax)

            gram_imag = ax_gram[0,1].imshow(np.imag(G.data))
            ax_gram[0,1].set_title("G (Imag)")
            divider = make_axes_locatable(ax_gram[0, 1])
            cax = divider.append_axes("right", size="5%", pad=0.05)
            cbar = plt.colorbar(gram_imag, cax)

            invG = linalg.inv(G.data)

            invgram_real = ax_gram[1,0].imshow(np.real(invG))
            ax_gram[1,0].set_title(r'G$^{-1}$ (real)')
            divider = make_axes_locatable(ax_gram[1, 0])
            cax = divider.append_axes("right", size="5%", pad=0.05)
            cbar = plt.colorbar(invgram_real, cax)

            invgram_imag = ax_gram[1,1].imshow(np.imag(invG))
            ax_gram[1,1].set_title(r'G$^{-1}$ (imag)')
            divider = make_axes_locatable(ax_gram[1, 1])
            cax = divider.append_axes("right", size="5%", pad=0.05)
            cbar = plt.colorbar(invgram_imag, cax)

            fig_gram.savefig(f"Gram_{timestep}")
            plt.close(fig_gram)
            #print(f"W {W.shape}\n", W)
            #"""

            S, _ = measurement_set.filter_data(S, W)

            D, V, c_idx = I_dp(S, G)
            W = W.data
            print ("Weights Matrix\n",W.shape,"\n",)
            S_corrected = (W @ ((V @ np.diag(D)) @ V.transpose().conj())) @ W.conj().T

            #S_corrected = (W @ ((V @ np.diag(D)) @linalg.inv(V))) @ linalg.inv(W) # linalg inv V not possible
            #S_corrected = (W @ invG @((V @ np.diag(D)) @V.conj().T)) @ invG @ W.conj().T
            print('BB Vis shape', S_corrected.shape,"OG Vis Shape", S.shape)
            """
            # max scaling 
            scaler1 = np.max(np.real(S.data))/ np.max(np.real(S_corrected))
            scaler2 = np.max(np.abs(S.data))/ np.max(np.abs(S_corrected))
            print (f"Real Scaler: {scaler1}\nAbs Scaler :{scaler2}")
            S_corrected = S_corrected * scaler2
            #"""

            if use_raw_vis:
                gram_corrected_visibilities.append(S.data)
            else:
                gram_corrected_visibilities.append(S_corrected)
                #print("UVW_baselines_t",UVW_baselines_t)
            """
            # try max scaling for BB / OG vis scaling
            real_OG = np.real(S.data)
            real_OG = np.clip(real_OG, 1e-7, real_OG.max())

            imag_OG = np.imag(S.data)
            imag_OG = imag_OG + np.abs(imag_OG.min())
            imag_OG = np.clip(imag_OG, 1e-7, imag_OG.max())
            
            real_BB = np.real(S_corrected)
            real_BB = np.clip(real_BB, 1e-7, real_BB.max())

            imag_BB = np.imag(S_corrected)
            imag_BB = imag_BB + np.abs(imag_BB.min())
            imag_BB = np.clip(imag_BB, 1e-7, imag_BB.max())
            
            fig_vis, ax_vis = plt.subplots(2, 3)

            og_real=ax_vis[0,0].imshow(real_OG,  norm=colors.LogNorm(vmin=1e-7, vmax=real_OG.max())) # ,  vmin =-2e4, vmax = 2e4)
            ax_vis[0,0].set_title("Original (real)\n Sum:%6.2f, \nMean:%6.2f, \nMedian:%6.2f, STD:%6.2f"%(np.sum(real_OG), np.mean(real_OG), np.median(real_OG), np.std(real_OG)))
            divider = make_axes_locatable(ax_vis[0, 0])
            cax = divider.append_axes("right", size="5%", pad=0.05)
            cbar = plt.colorbar(og_real, cax)

            og_imag=ax_vis[1,0].imshow(imag_OG,  norm=colors.LogNorm(vmin=1e-7, vmax=imag_OG.max())) # ,  vmin =-2e4, vmax = 2e4)
            ax_vis[1,0].set_title("Original (imag)\n Sum:%6.2f, \nMean:%6.2f, \nMedian:%6.2f, STD:%6.2f"%(np.sum(imag_OG), np.mean(imag_OG), np.median(imag_OG), np.std(imag_OG)))
            divider = make_axes_locatable(ax_vis[1, 0])
            cax = divider.append_axes("right", size="5%", pad=0.05)
            cbar = plt.colorbar(og_imag, cax)

            de_real=ax_vis[0,1].imshow(real_BB,  norm=colors.LogNorm(vmin=1e-7, vmax=real_BB.max())) # ,  vmin =-2e4, vmax = 2e4)
            ax_vis[0,1].set_title("BB (real)\n Sum:%6.2f, \nMean:%6.2f, \nMedian:%6.2f, STD:%6.2f"%(np.sum(real_BB), np.mean(real_BB), np.median(real_BB), np.std(real_BB)))
            divider = make_axes_locatable(ax_vis[0, 1])
            cax = divider.append_axes("right", size="5%", pad=0.05)
            cbar = plt.colorbar(de_real, cax)

            de_imag=ax_vis[1,1].imshow(imag_BB,  norm=colors.LogNorm(vmin=1e-7, vmax=imag_BB.max())) # ,  vmin =-2e4, vmax = 2e4)
            ax_vis[1,1].set_title("BB (imag)\n Sum:%6.2f, \nMean:%6.2f, \nMedian:%6.2f, STD:%6.2f"%(np.sum(imag_BB), np.mean(imag_BB), np.median(imag_BB), np.std(imag_BB)))
            divider = make_axes_locatable(ax_vis[1, 1])
            cax = divider.append_axes("right", size="5%", pad=0.05)
            cbar = plt.colorbar(de_imag, cax)

            diff_real=ax_vis[0,2].imshow(real_OG/real_BB,  norm=colors.LogNorm(vmin=1e-7, vmax=(real_OG/real_BB).max())) # ,  vmin =-2e4, vmax = 2e4)
            ax_vis[0,2].set_title("OG/BB (real)\n Sum:%6.2f, \nMean:%6.2f, \nMedian:%6.2f, STD:%6.2f"%(np.sum(real_OG/real_BB), np.mean(real_OG/real_BB), np.median(real_OG/real_BB), np.std(real_OG/real_BB)))
            divider = make_axes_locatable(ax_vis[0, 2])
            cax = divider.append_axes("right", size="5%", pad=0.05)
            cbar = plt.colorbar(diff_real, cax)

            diff_imag=ax_vis[1,2].imshow(imag_OG/imag_BB,  norm=colors.LogNorm(vmin=1e-7, vmax=(imag_OG/imag_BB).max())) # ,  vmin =-2e4, vmax = 2e4)
            ax_vis[1,2].set_title("OG/BB (imag)\n Sum:%6.2f, \nMean:%6.2f, \nMedian:%6.2f, STD:%6.2f"%((np.sum(imag_OG/imag_BB), np.mean(imag_OG/imag_BB), np.median(imag_OG/imag_BB), np.std(imag_OG/imag_BB))))
            divider = make_axes_locatable(ax_vis[1, 2])
            cax = divider.append_axes("right", size="5%", pad=0.05)
            cbar = plt.colorbar(diff_imag, cax)

            fig_vis.tight_layout()
            fig_vis.savefig("Visibilities_%d"%timestep)
            timestep+=1

            plt.close(fig_vis)
            #"""

        UVW_baselines = np.stack(UVW_baselines, axis=0)
        gram_corrected_visibilities = np.stack(gram_corrected_visibilities, axis=0).reshape(-1)
        
        UVW_baselines=UVW_baselines.reshape(-1,3)
        w_correction = np.exp(1j * UVW_baselines[:, -1])

        if not use_raw_vis:
            gram_corrected_visibilities *= w_correction

        lmn_grid = lmn_grid.reshape(3, -1)
        grid_center = lmn_grid.mean(axis=-1)
        lmn_grid -= grid_center[:, None]
        lmn_grid = lmn_grid.reshape(3, -1)

        UVW_baselines = 2 * np.pi * UVW_baselines.T.reshape(3, -1) / wl

        print (f"Final UVW before NUFFT: {UVW_baselines}")

        # second 2 pi/ wl factor!!!
        #UVW_baselines =  UVW_baselines.T.reshape(3, -1) 

        print ("Nufft Portion begins")

        if do3D:
            outfilename += "3D"
            if doPlan:
                outfilename += "_plan"
                plan = finufft.Plan(nufft_type=3, n_modes_or_dim=3, eps=1e-4, isign=1)       
                plan.setpts(x= UVW_baselines[0], y=UVW_baselines[1], z=UVW_baselines[2],
                            s=lmn_grid[0], t=lmn_grid[1],u=lmn_grid[2])
                V = gram_corrected_visibilities #*prephasing
                print('V', V)
                bb_image = np.real(plan.execute(V)) 
                bb_image = bb_image.reshape(pix_xyz.shape[1:])
            else:
                ##########################################################################################
                print ("Nufft 3D portion begins")
                bb_image = finufft.nufft3d3(x= UVW_baselines[0],
                                            y= UVW_baselines[1],
                                            z= UVW_baselines[2],
                                            s=lmn_grid[0],
                                            t=lmn_grid[1],
                                            u=lmn_grid[2],
                                            c=gram_corrected_visibilities, eps=1e-4)
                print ("Nufft 3D portion ends")
                bb_image = np.real(bb_image)
                bb_image = bb_image.reshape(pix_xyz.shape[1:])
            ##########################################################################################
        else:
            outfilename += "2D"
            scaling = 2 * lim / N_pix  
            if doPlan:
                outfilename += "_plan"
                ##########################################################################################
                plan = finufft.Plan(nufft_type=1, n_modes_or_dim= (N_pix, N_pix), eps=1e-4, isign=1)
                plan.setpts(x= UVW_baselines[1], y= UVW_baselines[0])  
                V = gram_corrected_visibilities
                bb_image = np.real(plan.execute(V))  
                ########################################################################################## 
            else:
                ##########################################################################################
                bb_image = finufft.nufft2d1(x= UVW_baselines[1],
                                            y= UVW_baselines[0],
                                            c=gram_corrected_visibilities,
                                            n_modes=N_pix, eps=1e-4)
                bb_image = np.real(bb_image)
                ##########################################################################################
        
        ################################################################################################
        """
        ### Sensitivity Field =========================================================
        # Parameter Estimation
        S_est = bb_pe.SensitivityFieldParameterEstimator(sigma=1)
        for t, f, S in ms.visibilities(channel_id=[channel_id], time_id=slice(time_start, time_end, time_chunk), column="DATA"):
            wl = constants.speed_of_light / f.to_value(u.Hz)
            XYZ = ms.instrument(t)
            W = ms.beamformer(XYZ, wl)
            G = gram(XYZ, W, wl)

            S_est.collect(G)
        N_eig = S_est.infer_parameters()

        # Imaging
        S_dp = bb_dp.SensitivityFieldDataProcessorBlock(N_eig)
        sensitivity_coeffs = []
        for t, f, S in ms.visibilities(channel_id=[channel_id], time_id=slice(time_start, time_end, time_chunk), column="DATA"):
            wl = constants.speed_of_light / f.to_value(u.Hz)
            XYZ = ms.instrument(t)
            W = ms.beamformer(XYZ, wl)
            G = gram(XYZ, W, wl)
            W = W.data
            D, V = S_dp(G)
            S_sensitivity = (W @ ((V @ np.diag(D)) @ V.transpose().conj())) @ W.transpose().conj()
            sensitivity_coeffs.append(S_sensitivity)

        sensitivity_coeffs = np.stack(sensitivity_coeffs, axis=0).reshape(-1)
        sensitivity_coeffs *= w_correction
        sensitivity_image = finufft.nufft2d1(x= UVW_baselines[:, 1],
                                            y= UVW_baselines[:, 0],
                                            c=sensitivity_coeffs,
                                            n_modes=N_pix, eps=1e-4)

        sensitivity_image = np.real(sensitivity_image)

        print(sensitivity_image.shape,sensitivity_image[0,0])

        I_lsq_eq = s2image.Image(bb_image / sensitivity_image, pix_xyz)
        ############################################################################################
        
        ### Sensitivity Field =========================================================
        # Parameter Estimation
        S_est = bb_pe.SensitivityFieldParameterEstimator(sigma=1)
        for t, f, S in ms.visibilities(channel_id=[channel_id], time_id=slice(time_start, time_end, time_chunk), column="DATA"):
            wl = constants.speed_of_light / f.to_value(u.Hz)
            XYZ = ms.instrument(t)
            W = ms.beamformer(XYZ, wl)
            G = gram(XYZ, W, wl)

            S_est.collect(G)
        N_eig = S_est.infer_parameters()

        # Imaging
        S_dp = bb_dp.SensitivityFieldDataProcessorBlock(N_eig)
        SV_dp = bb_dp.VirtualVisibilitiesDataProcessingBlock(N_eig, filters=('lsq',))
        sensitivity_coeffs = []
        for t, f, S in ms.visibilities(channel_id=[channel_id], time_id=slice(time_start, time_end, time_chunk), column="DATA"):
            wl = constants.speed_of_light / f.to_value(u.Hz)
            XYZ = ms.instrument(t)
            W = ms.beamformer(XYZ, wl)
            G = gram(XYZ, W, wl)
            D, V = S_dp(G)
            S_sensitivity = SV_dp(D, V, W, cluster_idx=np.zeros(N_eig, dtype=int))
            sensitivity_coeffs.append(S_sensitivity)

        sensitivity_coeffs = np.stack(sensitivity_coeffs, axis=0).reshape(-1)
        nufft_imager = bb_fd.NUFFT_IMFS_Block(wl=wl, UVW=UVW_baselines.T, grid_size=N_pix, FoV=FoV,
                                            field_center=source, eps=1e-3, w_term=True,
                                            n_trans=1, precision='single')
        print(nufft_imager._synthesizer._inner_fft_sizes)
        sensitivity_image = nufft_imager(sensitivity_coeffs)
        

        I_lsq_eq = s2image.Image(bb_image / sensitivity_image, nufft_imager._synthesizer.xyz_grid)
        #I_sqrt_eq = s2image.Image(sqrt_image / sensitivity_image, nufft_imager._synthesizer.xyz_grid)
        """
        I_lsq_eq = s2image.Image(bb_image, pix_xyz)

        ##################################################################################
        #"""
        t2 = tt.time()
        #print(f'Elapsed time: {t2 - t1} seconds.')

        fig, ax = plt.subplots(1, 2)
        I_lsq_eq.draw( ax=ax[0], data_kwargs=dict(cmap='cubehelix'), show_gridlines=True)
        ax[0].set_title(outfilename)

        WSClean_image = ap_fits.getdata(WSClean_image_path)[0, :, :]
        if (WSClean_image.shape[0] == 1):
            WSClean_image = WSClean_image[0, :, :]
        WSClean_scale= ax[1].imshow((WSClean_image), cmap='cubehelix')
        ax[1].set_title("WSClean Image")
        divider = make_axes_locatable(ax[1])
        cax = divider.append_axes("right", size="5%", pad=0.05)

        cbar = plt.colorbar(WSClean_scale, cax)
        plt.savefig(outfilename)
        #plt.show()

        gaussian=np.exp(-(Lpix ** 2 + Mpix ** 2)/(4*lim))
        gridded_visibilities=np.sqrt(np.abs(np.fft.fftshift(np.fft.fft2(np.fft.ifftshift(gaussian*bb_image)))))
        gridded_visibilities[int(gridded_visibilities.shape[0]/2)-2:int(gridded_visibilities.shape[0]/2)+2, int(gridded_visibilities.shape[1]/2)-2:int(gridded_visibilities.shape[1]/2)+2]=0
        #plt.figure()
        #plt.imshow(np.flipud(gridded_visibilities), cmap='cubehelix')
        #plt.show()
    
